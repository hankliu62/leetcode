/**
 * 有效的数独
 *
 * 判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。
 *  数字 1-9 在每一行只能出现一次。
 *  数字 1-9 在每一列只能出现一次。
 *  数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。
 *
 * 数独部分空格内已填入了数字，空白格用 '.' 表示。
 *
 * 示例 1:
 *  输入:
 *  [
 *    ["5","3",".",".","7",".",".",".","."],
 *    ["6",".",".","1","9","5",".",".","."],
 *    [".","9","8",".",".",".",".","6","."],
 *    ["8",".",".",".","6",".",".",".","3"],
 *    ["4",".",".","8",".","3",".",".","1"],
 *    ["7",".",".",".","2",".",".",".","6"],
 *    [".","6",".",".",".",".","2","8","."],
 *    [".",".",".","4","1","9",".",".","5"],
 *    [".",".",".",".","8",".",".","7","9"]
 *  ]
 *  输出: true
 *
 * 示例 2:
 *  输入:
 *  [
 *    ["8","3",".",".","7",".",".",".","."],
 *    ["6",".",".","1","9","5",".",".","."],
 *    [".","9","8",".",".",".",".","6","."],
 *    ["8",".",".",".","6",".",".",".","3"],
 *    ["4",".",".","8",".","3",".",".","1"],
 *    ["7",".",".",".","2",".",".",".","6"],
 *    [".","6",".",".",".",".","2","8","."],
 *    [".",".",".","4","1","9",".",".","5"],
 *    [".",".",".",".","8",".",".","7","9"]
 *  ]
 *  输出: false
 *
 * 解释:
 *  除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。
 *  但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。
 *
 * 说明:
 *  一个有效的数独（部分已被填充）不一定是可解的。
 *  只需要根据以上规则，验证已经填入的数字是否有效即可。
 *  给定数独序列只包含数字 1-9 和字符 '.' 。
 *  给定数独永远是 9x9 形式的。
 */

/**
 * 解题思路：
 *  一个循环二维数组，当元素是数字时，存到判断记录位置变量中是否存在在数字的key
 *    - 存在：判断横坐标或者纵坐标是否相等，相等表示在同一行或者列，返回false;
 *        在通过当前元素的横纵坐标位置除以3向下取整以及缓存中的坐标横纵坐标位置除以3向下取整是否相等，相等表示在同一个3*3的格子内，返回false;
 *        否则，将当前元素的坐标添加到缓存变量中
 *    - 不存在：将当前元素的坐标添加到缓存变量中
 */

/**
 * @param {character[][]} board
 * @return {boolean}
 */
var isValidSudoku = function(board) {
  var marked = {};
  for (var i = 0; i < board.length; i ++) {
    for (var j = 0; j < board[i].length; j ++) {
      var num = board[i][j];
      if (num === '.') {
        continue;
      }

      if (marked[num]) {
        var positions = marked[num];
        for (var position of positions) {
          // 在同一行或者同一列上
          if (position[0] === i || position[1] === j) {
            return false;
          }

          // 在3*3格子内
          if (Math.floor(position[0] / 3) === Math.floor(i / 3) && Math.floor(position[1] / 3) === Math.floor(j / 3)) {
            return false;
          }
        }

        marked[num].push([i, j]);
      } else {
        marked[num] = [[i, j]];
      }
    }
  }

  return true;
};
