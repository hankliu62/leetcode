
/**
 * 给定一个整数 n ，返回 n! 结果中尾随零的数量。
 * 提示 n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1
 *
 * 示例 1：
 *  - 输入：n = 3
 *  - 输出：0
 *  - 解释：3! = 6 ，不含尾随 0
 *
 * 示例 2：
 *  - 输入：n = 5
 *  - 输出：1
 *  - 解释：5! = 120 ，有一个尾随 0
 *
 * 示例 3：
 *  - 输入：n = 0
 *  - 输出：0
 *
 * 提示：
 *  - 0 <= n <= 10**4
 *
 * 进阶：你可以设计并实现对数时间复杂度的算法来解决此问题吗？
 *
 */

/**
 * 数学题
 * 只有因子10能够使末尾0增加(1 x 10 = 10, 2 x 10 = 20)
 * 而10 = 2 x 5
 * e.g. 6! = 1 x 2 x 3 x 4 x 5 x 6,只有2x5能构造尾随0
 * e.g. 10! = 2 x 4 x 5 x 6 x 8 x 10 (只关注2与5)
 *          = 2 x (2x2) x 5 x (2x3) x (2x2x2) x (2x5)
 * 因子2出现肯定比5多，而每一个2x5都能构造出一个10增加1个尾随0，因此需要求出所有5的个数
 * 以130为例：
 * 第一次除以5时得到26，表明存在26个包含 [一] 个因数5的数；
 * 第二次除以5得到5，表明存在5个包含 [二] 个因数5的数(第一个因数5已经在第一次运算的时候统计)；
 * 第三次除以5得到1，表明存在1个包含 [三] 个因数5的数(前两个因数5已经在前两次运算的时候统计了)；
 * 得到[1, n]中所有5的因数的个数 26 + 5 + 1 = 32
 *
 * @param {number} n
 * @returns {number}
 */
function trailingZeroes(n: number): number {
  let result = 0;

  while (n > 1) {
    n = (n / 5) | 0;
    result += n;
  }

  return result;
};
